# Тестовое задание от компании ReactionGames.

**(!)** В репозитории лежит упрощенная диаграмма классов

### Комментарий
Для реализации выбран компонентный подход. Выделяются маленькие самостоятельные компоненты с единой ответственностью. Такой подход помогает добиться хорошей переносимости механик и расширяемости. Реализации конкретных поведений выполнены в максимально упрощенной форме, но могут быть легко заменены более продуманными и сложными реализациями.

### Описание
Инфраструктурно выбран простой и быстро реализуемый вариант с общей GameFactory в виде монобеха и сериализованными ссылками на нее у интересантов. Такая конструкция впоследсвии легко разделяется и выносится в виде набора сервисов с отдельными интерфейсами, через которые ее можено, например, везде заинжектить.

Инстанцирование агентов происходит в размещенных на сцене Spawner'ах через GameFactory. Она же их конфигурирует, согласно вынесенным в виде ScriptableObject конфигов.
Агенты представляют из себя наборы компонентов реализующих требуемое поведение.

**PatrolEnemy** содержит: 
 - AgentMover - для передвижения по точкам через.
 - KamikazeContact - для нанесения урона при контакте.
 - Death - для обработки логики уничтожения.
 - Patrol - для последовательного обхода набора позиций.

**HunterEnemy** также содержит AgentMover, KamikazeContact, и Death, а дополнительно:
 - TargetChaiser наследованный от Follow - для преследования цели.
 - TargetSelector - для поиска и выбора цели.
 - Agro - для включения/выключения Follow поведения при наличии/отсутствии цели.

**ShooterEnemy** в свою очередь содержит AgentMover, TargetSelector и компоненты для осуществления стрельбы:
 - ToTargetRotator тоже наследованный от Follow и включаемый Agro - для прицеливания.
 - Shooting наследованный от Attack - для осуществления стрельбы из Weapon
 - AttackRangeChecker - для активации компонента атаки в случае приближения цели. 

Enemy и Hero пустые маркерные компоненты. Через них работает FriendOrFoeSystem используемая для анализа целей.

Триггерные зоны разнесены по слоям и отслеживаются через TriggerObserver.
